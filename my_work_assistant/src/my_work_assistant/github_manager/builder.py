"""my_work_assistant.github_manager.builder.

Render managed GitHub files from bundled templates.

This module provides utilities to load Jinja2 templates, render them into the
configured GitHub root, and protect unmanaged files from accidental overwrite
by requiring a standard disclaimer banner. All public functions include
type-annotated docstrings.
"""

from __future__ import annotations

from pathlib import Path

from jinja2 import Template

from ..core.config import CONFIG_ROOT, USER_ROOT, load_config
from ..core.exceptions import GitHubFileError

__all__ = ["DISCLAIMER", "render_templates"]

DISCLAIMER = (
    "⚙️  This file is generated and managed by the My Work Assistant MCP Server."
)


def _load_template(path: Path) -> Template:
    """Load a Jinja2 template from disk.

    Args:
        path (Path): Path to the template file.

    Returns:
        Template: Compiled Jinja2 template instance.

    Raises:
        GitHubFileError: If the template cannot be read.

    Example:
        >>> isinstance(_load_template(Path('sample.j2')), Template)  # doctest: +SKIP
    """
    try:
        return Template(path.read_text(encoding="utf-8"))
    except OSError as exc:  # pragma: no cover
        raise GitHubFileError("Failed to read template", {"path": str(path)}) from exc


def _write_file(target: Path, content: str) -> None:
    """Write rendered content to disk respecting disclaimers.

    Args:
        target (Path): Output file path.
        content (str): Rendered template content.

    Raises:
        GitHubFileError: If writing fails or disclaimer safeguards are triggered.

    Example:
        >>> _write_file(Path('tmp.md'), 'content')  # doctest: +SKIP
    """
    if target.exists():
        existing = target.read_text(encoding="utf-8")
        if DISCLAIMER not in existing:
            raise GitHubFileError(
                "Refusing to overwrite unmanaged file", {"path": str(target)}
            )
    target.parent.mkdir(parents=True, exist_ok=True)
    target.write_text(content, encoding="utf-8")


def render_templates() -> list[Path]:
    """Render configured templates into the repository.

    This now renders category files first (instructions/prompts/chatmodes),
    then embeds their content into ``copilot-instructions.md`` so Copilot Chat
    receives a single, self-contained reference file.

    Returns:
        list[Path]: Paths that were rendered or refreshed.

    Raises:
        GitHubFileError: If rendering fails.

    Example:
        >>> render_templates()  # doctest: +SKIP
    """
    config = load_config()["github_manager"]
    rendered: list[Path] = []
    template_root = CONFIG_ROOT.parent / "github"
    github_root = Path(config.get("github_root", ".github"))

    def extract_body(content: str) -> str:
        """Return content without YAML front matter and leading comments.

        Heuristic: find two lines that start with '---' and return text after
        the second delimiter. Falls back to original content if not found.
        """
        lines = content.splitlines()
        dashes_idx: list[int] = [i for i, ln in enumerate(lines) if ln.strip() == "---"]
        if len(dashes_idx) >= 2:
            return "\n".join(lines[dashes_idx[1] + 1 :]).strip()
        return content

    def parse_front_matter_local(content: str) -> dict[str, str]:
        """Minimal front matter parser to avoid circular imports.

        Expects a YAML-like header between '---' lines; returns key/value strings.
        """
        start = content.find("---\n")
        if start == -1:
            return {}
        end = content.find("\n---", start + 4)
        if end == -1:
            return {}
        block = content[start + 4 : end]
        data: dict[str, str] = {}
        for line in block.splitlines():
            if ":" not in line:
                continue
            key, value = line.split(":", 1)
            data[key.strip()] = value.strip()
        return data

    # 1) Render instructions/prompts/chatmodes first
    instr_targets: list[Path] = []
    prompt_targets: list[Path] = []
    chatmode_targets: list[Path] = []
    doc_targets: list[Path] = []

    if config.get("instructions_enabled", True):
        path = (
            template_root / "instructions" / "default-guidelines.instructions.mwa.md.j2"
        )
        target = github_root / "instructions" / "default-guidelines.instructions.mwa.md"
        template = _load_template(path)
        _write_file(
            target,
            template.render(
                body="- Follow the docs generated by `python -m my_work_assistant init` in path `.my_work_assistant/docs`."
            ),
        )
        rendered.append(target)
        instr_targets.append(target)

    if config.get("prompts_enabled", True):
        for template_name in [
            "document-api.prompt.mwa.md.j2",
            "review-code.prompt.mwa.md.j2",
            "onboarding-plan.prompt.mwa.md.j2",
        ]:
            template = _load_template(template_root / "prompts" / template_name)
            target_name = template_name.replace(".j2", "")
            target = github_root / "prompts" / target_name
            _write_file(
                target,
                template.render(
                    body="Generated by My Work Assistant.\n\n## TODO: Verify this is in alignment with the MP Server goals."
                ),
            )
            rendered.append(target)
            prompt_targets.append(target)
    # Compute priorities line from prompt metadata (front matter)
    priorities_line = ""
    available_topics: set[str] = set()
    category_best: dict[str, tuple[int, str]] = {}
    if prompt_targets:
        items: list[tuple[int, str]] = []
        for p in prompt_targets:
            try:
                meta = parse_front_matter_local(p.read_text(encoding="utf-8"))
                pr = int(meta.get("priority", 999))  # default low priority
                topic = str(meta.get("topic", p.stem.split(".prompt")[0]))
                category = str(meta.get("category", "")).strip()
                items.append((pr, topic))
                available_topics.add(topic)
                if category:
                    prev = category_best.get(category)
                    if prev is None or pr < prev[0]:
                        category_best[category] = (pr, topic)
            except Exception:
                topic = p.stem.split(".prompt")[0]
                items.append((999, topic))
                available_topics.add(topic)
        items.sort(key=lambda t: t[0])
        priorities_line = ", ".join(topic for _, topic in items)

    # Derive a concise guidance sentence from categories: code/docs/onboarding.
    guidance_line = "Pick the highest-priority prompt for your task."
    parts: list[str] = []

    def _recommend(category: str, prefix: str) -> None:
        item = category_best.get(category)
        if item:
            topic = item[1]
            clause = (prefix.lower() if parts else prefix) + f", start with {topic}"
            parts.append(clause)

    _recommend("code", "For code changes")
    _recommend("docs", "For API/docs")
    _recommend("onboarding", "For onboarding")
    if parts:
        guidance_line = "; ".join(parts) + "."

    if config.get("chatmodes_enabled", True):
        for template_name in [
            "reviewer.chatmode.mwa.md.j2",
            "docwriter.chatmode.mwa.md.j2",
        ]:
            template = _load_template(template_root / "chatmodes" / template_name)
            target_name = template_name.replace(".j2", "")
            target = github_root / "chatmodes" / target_name
            _write_file(
                target,
                template.render(
                    body="Generated persona.\n\n## TODO: Verify this is in alignment with the MP Server goals."
                ),
            )
            rendered.append(target)
            chatmode_targets.append(target)

    # Optional: embed user docs if present
    docs_dir = USER_ROOT / "docs"
    if docs_dir.exists():
        for p in sorted(docs_dir.glob("*.md")):
            doc_targets.append(p)

    # 2) Render copilot-instructions last, embedding content
    if config.get("copilot_instructions_enabled", True):
        path = template_root / "copilot-instructions.md.j2"
        target = github_root / "copilot-instructions.md"
        template = _load_template(path)

        def _summarize_markdown(raw: str) -> str:
            """Return a short one-line summary from the first heading/paragraph.

            Heuristics only; keeps things lightweight and zero-dependency.
            """
            if not raw:
                return ""
            lines = [ln.strip() for ln in raw.splitlines()]
            # Prefer first ATX heading (# ...)
            heading = next((ln.lstrip("# ") for ln in lines if ln.startswith("#")), "")
            # Find first non-empty paragraph line (not a heading or fence)
            para = next(
                (ln for ln in lines if ln and not ln.startswith(("#", "<!--", "```"))),
                "",
            )
            if heading and para and heading != para:
                combo = f"{heading} — {para}"
            else:
                combo = heading or para
            return combo[:240]

        def pack(paths: list[Path]) -> list[dict[str, str]]:
            items: list[dict[str, str]] = []
            for p in paths:
                try:
                    raw = p.read_text(encoding="utf-8")
                except OSError:
                    raw = ""
                items.append(
                    {
                        "name": p.name,
                        "path": str(p),
                        "content": extract_body(raw),
                        "summary": _summarize_markdown(raw),
                    }
                )
            return items

        docs_summary_only = bool(config.get("docs_summary_only", False))
        content = template.render(
            additional_notes="These instructions are managed.",
            embedded_instructions=pack(instr_targets),
            embedded_prompts=pack(prompt_targets),
            embedded_chatmodes=pack(chatmode_targets),
            embedded_docs=pack(doc_targets),
            priorities_line=priorities_line,
            guidance_line=guidance_line,
            docs_summary_only=docs_summary_only,
        )
        _write_file(target, content)
        rendered.append(target)

    return rendered
