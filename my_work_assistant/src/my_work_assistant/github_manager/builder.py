"""my_work_assistant.github_manager.builder.

Render managed GitHub files from bundled templates.

This module provides utilities to load Jinja2 templates, render them into the
configured GitHub root, and protect unmanaged files from accidental overwrite
by requiring a standard disclaimer banner. All public functions include
type-annotated docstrings.
"""

from __future__ import annotations

from pathlib import Path

from jinja2 import Template

from ..core.config import CONFIG_ROOT, load_config
from ..core.exceptions import GitHubFileError

__all__ = ["DISCLAIMER", "render_templates"]

DISCLAIMER = (
    "⚙️  This file is generated and managed by the My Work Assistant MCP Server."
)


def _load_template(path: Path) -> Template:
    """Load a Jinja2 template from disk.

    Args:
        path (Path): Path to the template file.

    Returns:
        Template: Compiled Jinja2 template instance.

    Raises:
        GitHubFileError: If the template cannot be read.

    Example:
        >>> isinstance(_load_template(Path('sample.j2')), Template)  # doctest: +SKIP
    """
    try:
        return Template(path.read_text(encoding="utf-8"))
    except OSError as exc:  # pragma: no cover
        raise GitHubFileError("Failed to read template", {"path": str(path)}) from exc


def _write_file(target: Path, content: str) -> None:
    """Write rendered content to disk respecting disclaimers.

    Args:
        target (Path): Output file path.
        content (str): Rendered template content.

    Raises:
        GitHubFileError: If writing fails or disclaimer safeguards are triggered.

    Example:
        >>> _write_file(Path('tmp.md'), 'content')  # doctest: +SKIP
    """
    if target.exists():
        existing = target.read_text(encoding="utf-8")
        if DISCLAIMER not in existing:
            raise GitHubFileError(
                "Refusing to overwrite unmanaged file", {"path": str(target)}
            )
    target.parent.mkdir(parents=True, exist_ok=True)
    target.write_text(content, encoding="utf-8")


def render_templates() -> list[Path]:
    """Render configured templates into the repository.

    This now renders category files first (instructions/prompts/chatmodes),
    then embeds their content into ``copilot-instructions.md`` so Copilot Chat
    receives a single, self-contained reference file.

    Returns:
        list[Path]: Paths that were rendered or refreshed.

    Raises:
        GitHubFileError: If rendering fails.

    Example:
        >>> render_templates()  # doctest: +SKIP
    """
    config = load_config()["github_manager"]
    rendered: list[Path] = []
    template_root = CONFIG_ROOT.parent / "github"
    github_root = Path(config.get("github_root", ".github"))

    def extract_body(content: str) -> str:
        """Return content without YAML front matter and leading comments.

        Heuristic: find two lines that start with '---' and return text after
        the second delimiter. Falls back to original content if not found.
        """
        lines = content.splitlines()
        dashes_idx: list[int] = [i for i, ln in enumerate(lines) if ln.strip() == "---"]
        if len(dashes_idx) >= 2:
            return "\n".join(lines[dashes_idx[1] + 1 :]).strip()
        return content

    # 1) Render instructions/prompts/chatmodes first
    instr_targets: list[Path] = []
    prompt_targets: list[Path] = []
    chatmode_targets: list[Path] = []

    if config.get("instructions_enabled", True):
        path = (
            template_root / "instructions" / "default-guidelines.instructions.mwa.md.j2"
        )
        target = github_root / "instructions" / "default-guidelines.instructions.mwa.md"
        template = _load_template(path)
        _write_file(
            target,
            template.render(
                body="- Follow the docs generated by `python -m my_work_assistant init` in path `.my_work_assistant/docs`."
            ),
        )
        rendered.append(target)
        instr_targets.append(target)

    if config.get("prompts_enabled", True):
        for template_name in [
            "document-api.prompt.mwa.md.j2",
            "review-code.prompt.mwa.md.j2",
            "onboarding-plan.prompt.mwa.md.j2",
        ]:
            template = _load_template(template_root / "prompts" / template_name)
            target_name = template_name.replace(".j2", "")
            target = github_root / "prompts" / target_name
            _write_file(
                target,
                template.render(
                    body="Generated by My Work Assistant.\n\n## TODO: Verify this is in alignment with the MP Server goals."
                ),
            )
            rendered.append(target)
            prompt_targets.append(target)

    if config.get("chatmodes_enabled", True):
        for template_name in [
            "reviewer.chatmode.mwa.md.j2",
            "docwriter.chatmode.mwa.md.j2",
        ]:
            template = _load_template(template_root / "chatmodes" / template_name)
            target_name = template_name.replace(".j2", "")
            target = github_root / "chatmodes" / target_name
            _write_file(
                target,
                template.render(
                    body="Generated persona.\n\n## TODO: Verify this is in alignment with the MP Server goals."
                ),
            )
            rendered.append(target)
            chatmode_targets.append(target)

    # 2) Render copilot-instructions last, embedding content
    if config.get("copilot_instructions_enabled", True):
        path = template_root / "copilot-instructions.md.j2"
        target = github_root / "copilot-instructions.md"
        template = _load_template(path)

        def pack(paths: list[Path]) -> list[dict[str, str]]:
            items: list[dict[str, str]] = []
            for p in paths:
                try:
                    raw = p.read_text(encoding="utf-8")
                except OSError:
                    raw = ""
                items.append(
                    {"name": p.name, "path": str(p), "content": extract_body(raw)}
                )
            return items

        content = template.render(
            additional_notes="These instructions are managed.",
            embedded_instructions=pack(instr_targets),
            embedded_prompts=pack(prompt_targets),
            embedded_chatmodes=pack(chatmode_targets),
        )
        _write_file(target, content)
        rendered.append(target)

    return rendered
